//
//  ___FILENAME___
//  ___PROJECTNAME___
//
//  Created by ___FULLUSERNAME___ on ___DATE___.
//  Copyright (c) ___YEAR___ ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the SergeyPetrachkov VIPER Xcode Templates so
//  you can apply VIPER architecture to your iOS projects
//

import UIKit
import SiberianVIPER

protocol ___VARIABLE_moduleName___PresenterInput: Awaitable, Startable, CloseableModule {
  var view: UIViewController! { get set }
  var output: ___VARIABLE_moduleName___PresenterOutput? { get set }
  var router: ___VARIABLE_moduleName___RoutingLogic? { get set }
  var interactor: ___VARIABLE_moduleName___InteractorInput? { get set }
  func presentSomething()
  func refresh()
  func fetch()
}
protocol ___VARIABLE_moduleName___PresenterOutput: AwaitableDelegate {
  func didChangeState(viewModel : ___VARIABLE_moduleName___.DataContext.ViewModel)
}

class ___VARIABLE_moduleName___Presenter: CollectionPresenter, ___VARIABLE_moduleName___PresenterInput {
  // MARK: - Essentials
  weak var view: UIViewController!
  weak var output: ___VARIABLE_moduleName___PresenterOutput?
  var viewModel: ___VARIABLE_moduleName___.DataContext.ViewModel! {
    didSet {
      self.awaitableModel = self.viewModel
    }
  }
  var router: ___VARIABLE_moduleName___RoutingLogic?
  var interactor: ___VARIABLE_moduleName___InteractorInput?
  // MARK: - Initializers
  init(moduleIn: ___VARIABLE_moduleName___.DataContext.ModuleIn) {
    self.viewModel = ___VARIABLE_moduleName___.DataContext.ViewModel(moduleIn: moduleIn)
  }
  deinit {
    print("___VARIABLE_moduleName___Presenter deinit is called")
  }
  // MARK: - Presenter Input
  func presentSomething() {
    // ask router to navigate somewhere or ask interactor for resources... it's up to you
    // like:
    // let requestParams = RequestParams()
    // self.interactor.getSomeData(requestParams: requestParams)
    // or:
    // let routingParams = RoutingParams(firstValue : self.viewModel.firstValue, secondValue: self.viewModel.secondValue)
    // self.router.showNextModule(from: self.view, with: routingParams)
  }
  
  func refresh() {
    self.fetchItems(reset: true)
  }
  func fetch() {
    self.fetchItems(reset: false)
  }
  // MARK: - Startable
  override func start() {
    super.start()
    self.awaitableDelegate = self.output
    self.awaitableModel = self.viewModel
    self.collectionModel = self.viewModel
    self.fetchItems(reset: true)
  }
  // MARK: - Base overrides
  @discardableResult override func fetchItems(reset: Bool) -> (skip: Int, take: Int) {
    if self.viewModel.isBusy {
      return (0,0)
    }
    let skipTake = super.fetchItems(reset: reset)
    self.interactor?.requestItems(request: ___VARIABLE_moduleName___.DataContext.Request(skip: skipTake.skip, take: skipTake.take))
    return skipTake
  }
  
  override func exitPendingState() {
    super.exitPendingState()
    self.viewModel.changeSet = []
  }
}
extension ___VARIABLE_moduleName___Presenter: ___VARIABLE_moduleName___InteractorOutput {
  // MARK: - Interactor output
  func didReceive(response: ___VARIABLE_moduleName___.DataContext.Response) {
    if response.originalRequest.skip == 0 {
      self.viewModel.items = []
    }
    response.items.enumerated().forEach({ (offset, _) in
      self.viewModel.changeSet.append(.new(IndexPath(row: self.viewModel.items.count + offset, section: 0)))
    })
    
    self.viewModel.items.append(contentsOf: response.items as [CollectionModel])
    self.output?.didChangeState(viewModel: self.viewModel)
    self.exitPendingState()
  }

  func didFail(with error: Error) {
    self.exitPendingState()
  }
}
extension ___VARIABLE_moduleName___Presenter: SiberianCollectionSource {
  func modelForSectionHeader(at index: Int) -> CollectionModel? {
    return nil
  }
  
  func heightForSectionHeader(at index: Int) -> CGFloat {
    return 0
  }
  
  func modelForSectionFooter(at index: Int) -> CollectionModel? {
    return nil
  }
  
  func heightForSectionFooter(at index: Int) -> CGFloat {
    return 0
  }
  
  func modelForSection(at index: Int) -> CollectionModel? {
    return nil
  }
  
  func numberOfSections() -> Int {
    return 1
  }
  
  var items: [CollectionModel] {
    return self.viewModel.items
  }
  
  var changeSet: [CollectionChange] {
    return self.viewModel.changeSet
  }
  
  func item(for indexPath: IndexPath) -> CollectionModel? {
    if indexPath.row >= self.items.count {
      return nil
    }
    return self.items[indexPath.row]
  }
  
  func numberOfItems(in section: Int) -> Int {
    return self.items.count
  }
}